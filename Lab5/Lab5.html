<html>
   <head>
      <meta http-equiv="Content-type" content="text/html; charset=iso-8859-2">
      <title>Lab</title>
      <link rel="StyleSheet" type="text/css" href="../../style.css" />
   </head>
   <body>

<h2>Lab</h2>

Zadanie jest kontynuacj± poprzedniego zadania.

<p>
Zadanie polega na stworzeniu interpretera jêzyka wyspecyfikowanego w poprzednich zajêciach.
Interpretacja powinna byæ wykonywana tylko wtedy, gdy poprzednie etapy zakoñczy³y siê sukcesem --
nie wyst±pi³y ¿adne b³êdy syntaktyczne lub semantyczne.


<h4>Implementacja</h4>
<p>
Do implementacji zadania nale¿y wykorzystaæ wzorzec <i>visitor</i>.
Tym razem nie bêdziemy u¿ywaæ implementacji z poprzednich zajêæ
(dla ka¿dej klasy z AST definicja funkcji <code>vistit_&lt;classname&gt;</code> w odpowiednim wizytorze),
lecz nale¿y u¿yæ implementacji opartej na dekoratorach.
W tym celu w wizytorze <code>Interpreter</code> nale¿y dla ka¿dej klasy z AST zdefiniowaæ metodê <code>visit</code>,
dekorowan± nazw± tej klasy.
</p>                                                                                                


<h4>Pamiêæ interpretera</h4>
<p>
Poza trywialnym przypadkiem jednego, globalnego zakresu, bie¿±ce warto¶ci zmiennych nie mog± byæ przechowywane w tablicy symboli.
W pozosta³ych przypadkach potrzebna jest osobna pamiêæ interpretera o strukturze stosu.
<!--Przydatne bêdzie rozró¿nienie na pamiêæ globaln± i funkcyjn±:-->
<ul>
<li>Pamiêæ globalna <code>globalMemory</code> s³u¿y do przechowywania warto¶ci zmiennych w zakresie globalnym i jego zakresach potomnych niefunkcyjnych. Pamiêæ ta mo¿ê zostaæ zaimplementowana jako instacja klasy <code>MemoryStack</code>.
<!--
<li><code>functionMemory</code> - pamiêæ do przechowywania warto¶ci zmiennych wszystkich wywo³añ funkcji.
Pamiêæ ta jest potrzebna, je¶li w jêzyku wystêpuj± definicje i wywo³ywania funkcji (potencjalnie dowolny poziom zagnie¿dzenia wywo³añ funkcji)
-->
</ul>


</p>


<h4>Przekazywanie sterowania</h4>
<p>
Do zaimplementowania przekazywania sterowania z instrukcji <code>break</code>,  <code>continue</code>
nie wystarczy u¿ycie zwyk³ej instrukcji <code>return</code>, gdy¿ wspomniane instrukcje mog± byæ zagnie¿dzone dowolnie g³êboko w pêtli.

Zamiast tego nale¿y pos³u¿yæ siê mechanizmem wyj±tków:
zg³aszanie wyj±tku przy interpretacji instrukcji <code>break</code> lub <code>continue</code>
oraz jego przechwytywanie w funkcjach <code>visit</code> interpretuj±cych pêtle (oraz w funkcji <code>visit</code> interpretuj±cej wywo³anie funkcji, je¶li jêzyk umo¿liwia definiowanie i wywo³ywanie funkcji).
</p>


<p>
Do stworzenia interpretera mo¿na wykorzystaæ pliki:
<ul>
<li> <a href="visit.py">visit.py</a> [Imlementation of visitor pattern <a href="http://curtis.schlak.com/2013/06/20/follow-up-to-python-visitor-pattern.html"> of Curtis Schlak</a>]
<li> <a href="Interpreter.py">Interpreter.py</a>
<li> <a href="Memory.py">Memory.py</a>
<li> <a href="Exceptions.py">Exceptions.py</a>
<li> <a href="main.py">main.py</a>
</body>
</html>

